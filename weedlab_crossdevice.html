<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeedLab Queue System - Cross Device</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a3a0f, #2d5016, #4a7c23);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: #fff;
            min-height: 100vh;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 20px 30px;
            border-radius: 20px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: #4CAF50;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #4CAF50;
            border-radius: 50%;
            animation: blink 2s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        .nav-links {
            display: flex;
            gap: 20px;
        }

        .nav-links a {
            color: #fff;
            text-decoration: none;
            padding: 12px 24px;
            border-radius: 25px;
            transition: all 0.3s;
            border: 1px solid rgba(76, 175, 80, 0.3);
            position: relative;
            overflow: hidden;
        }

        .nav-links a:hover {
            background: rgba(76, 175, 80, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        /* Server Status */
        .server-status {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 15px;
            border-radius: 15px;
            margin-bottom: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .server-status.disconnected {
            background: rgba(244, 67, 54, 0.2);
            border-color: rgba(244, 67, 54, 0.3);
        }

        .server-status::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(76, 175, 80, 0.2), transparent);
            animation: serverPulse 3s infinite;
        }

        @keyframes serverPulse {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        /* Login Section */
        .login-section {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 50px;
            border-radius: 25px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }

        .login-form {
            max-width: 450px;
            margin: 0 auto;
        }

        .form-group {
            margin-bottom: 25px;
            text-align: left;
            position: relative;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #e8f5e8;
            font-weight: 500;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid rgba(76, 175, 80, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 16px;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            transform: translateY(-2px);
        }

        .form-group input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 25px;
            color: #e8f5e8;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin: 0;
        }

        .btn {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 15px 35px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.6);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Queue Section */
        .queue-section {
            display: none;
        }

        .queue-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 35px;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(76, 175, 80, 0.3);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.3);
        }

        .stat-card:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #4CAF50, #66BB6A);
        }

        .stat-number {
            font-size: 3em;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #66BB6A);
            border-radius: 4px;
            transition: width 1s ease;
        }

        .queue-list {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 20px;
            padding: 35px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .queue-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            margin-bottom: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border-left: 4px solid #4CAF50;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .queue-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .queue-item.current {
            background: rgba(76, 175, 80, 0.2);
            border-left-color: #FFC107;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }

        .user-tag {
            background: linear-gradient(135deg, #4CAF50, #66BB6A);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: 0 2px 10px rgba(76, 175, 80, 0.3);
        }

        .cooldown-timer {
            background: rgba(255, 193, 7, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 193, 7, 0.5);
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            margin-bottom: 25px;
            box-shadow: 0 8px 25px rgba(255, 193, 7, 0.2);
        }

        .timer-display {
            font-size: 2.5em;
            font-weight: bold;
            color: #FFC107;
            text-shadow: 0 0 20px rgba(255, 193, 7, 0.5);
            font-family: 'Courier New', monospace;
        }

        /* Activity Feed */
        .activity-feed {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            margin-top: 25px;
        }

        .activity-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 12px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-size: 14px;
        }

        .activity-time {
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
        }

        /* Notifications */
        .notification {
            position: fixed;
            top: 100px;
            right: 30px;
            background: rgba(76, 175, 80, 0.9);
            backdrop-filter: blur(10px);
            color: white;
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transform: translateX(400px);
            transition: transform 0.5s ease;
            z-index: 1000;
            border-left: 4px solid #4CAF50;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.error {
            background: rgba(244, 67, 54, 0.9);
            border-left-color: #f44336;
        }

        .notification.warning {
            background: rgba(255, 152, 0, 0.9);
            border-left-color: #ff9800;
        }

        .hidden {
            display: none !important;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #4CAF50;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* User Highlight */
        .user-highlight {
            border-left-color: #FFC107 !important;
            background: rgba(255, 193, 7, 0.1) !important;
        }
        
        .queue-item .user-info .user-avatar {
            position: relative;
        }
        
        .queue-item.current .user-avatar::after {
            content: 'üëë';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 12px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 20px;
                padding: 20px;
            }

            .nav-links {
                flex-wrap: wrap;
                justify-content: center;
            }

            .queue-stats {
                grid-template-columns: 1fr;
            }

            .login-section {
                padding: 30px 20px;
            }

            .queue-item {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                <div class="logo-icon">üåø</div>
                <div>
                    <h1>WeedLab Queue System</h1>
                    <div class="system-status">
                        <div class="status-dot"></div>
                        <span id="systemStatus">üü¢ Global Network Online</span>
                    </div>
                </div>
            </div>
            <nav class="nav-links">
                <a href="#" id="homeLink" onclick="showQueueSection()">üè° Home</a>
                <a href="#" id="logoutLink" class="hidden" onclick="logout()">üö™ Exit Lab</a>
            </nav>
        </div>

        <!-- Server Status -->
        <div class="server-status" id="serverStatus">
            <span id="serverStatusText">üåê Connected to Global WeedLab Network</span>
            <div style="margin-top: 10px;">
                <span>üë• Active Researchers: <span id="onlineCount">0</span></span>
                <span style="margin-left: 20px;">üïí Last Sync: <span id="lastSync">Now</span></span>
            </div>
        </div>

        <!-- Login Section -->
        <div id="loginSection" class="login-section">
            <h2>üåø Global Lab Access Portal</h2>
            <p style="margin: 25px 0; opacity: 0.8;">üõ°Ô∏è Cross-Device Authentication System</p>
            
            <div class="login-form">
                <div class="form-group">
                    <label for="username">üë®‚Äçüî¨ Researcher ID</label>
                    <input type="text" id="username" placeholder="Enter your researcher ID">
                </div>
                <div class="form-group">
                    <label for="password">üîê Lab Access Code</label>
                    <input type="password" id="password" placeholder="Enter your access code">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="rememberMe" checked>
                    <label for="rememberMe">üîí Remember me across all devices</label>
                </div>
                <button class="btn" onclick="login()">
                    <span id="loginText">üöÄ Enter Global Lab</span>
                    <span id="loginLoader" class="loading hidden"></span>
                </button>
            </div>
        </div>

        <!-- Queue Section -->
        <div id="queueSection" class="queue-section">
            <!-- Cooldown Timer -->
            <div id="cooldownTimer" class="cooldown-timer hidden">
                <h3>‚è≥ Lab Cooldown Active</h3>
                <p>üî¨ Next lab session available in:</p>
                <div class="timer-display" id="timerDisplay">00:00:00</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="cooldownProgress"></div>
                </div>
            </div>

            <!-- Queue Stats -->
            <div class="queue-stats">
                <div class="stat-card">
                    <div class="stat-number" id="queuePosition">-</div>
                    <div>üéØ Your Lab Position</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="positionProgress"></div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="totalQueue">0</div>
                    <div>üë• Total Researchers</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="totalProgress"></div>
                    </div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="serverLoad">0%</div>
                    <div>üñ•Ô∏è Global Load</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="loadProgress"></div>
                    </div>
                </div>
            </div>

            <!-- Queue Controls -->
            <div style="text-align: center; margin-bottom: 35px;">
                <button class="btn" id="joinQueueBtn" onclick="joinQueue()">
                    üåø Join Global Queue
                </button>
                <button class="btn btn-danger" id="leaveQueueBtn" onclick="leaveQueue()" style="display: none; background: linear-gradient(135deg, #f44336, #e57373);">
                    üö´ Exit Queue
                </button>
                <button class="btn btn-info" onclick="refreshQueue()" style="margin-left: 10px; background: linear-gradient(135deg, #2196F3, #64B5F6);">
                    üîÑ Refresh Status
                </button>
            </div>

            <!-- Queue List -->
            <div class="queue-list">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                    <h3>üåø Global Queue Status</h3>
                    <div style="display: flex; gap: 15px;">
                        <span style="color: rgba(255,255,255,0.7); font-size: 14px;">
                            üïí Last Updated: <span id="lastUpdate">Now</span>
                        </span>
                    </div>
                </div>
                <div id="queueList">
                    <!-- Queue items will be populated here -->
                </div>
            </div>

            <!-- Activity Feed -->
            <div class="activity-feed">
                <h3>üìà Global Lab Activity</h3>
                <div id="activityList">
                    <!-- Activity items will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification">
        <span id="notificationText"></span>
    </div>

    <script>
        // Global Cross-Device Database System using advanced techniques
        class GlobalLabDatabase {
            constructor() {
                this.dbKey = 'weedlab_global_v4';
                this.sessionKey = 'weedlab_session_v4';
                this.syncInterval = 2000; // 2 seconds
                this.isOnline = navigator.onLine;
                this.changeListeners = new Set();
                this.lastSyncTime = 0;
                
                this.initializeDatabase();
                this.setupCrossDeviceSync();
            }

            // Initialize database with advanced fallback system
            async initializeDatabase() {
                try {
                    // Try to load from multiple sources
                    let data = await this.loadFromAnySources() || this.getDefaultData();
                    
                    // Ensure data integrity
                    if (!this.validateData(data)) {
                        data = this.getDefaultData();
                    }
                    
                    this.saveToAllSources(data);
                    this.startRealTimeSync();
                    
                    console.log('üåø Global database initialized successfully');
                } catch (error) {
                    console.error('Database initialization failed:', error);
                    this.handleInitializationError();
                }
            }

            getDefaultData() {
                return {
                    queue: [],
                    users: [
                        { 
                            username: 'admin', 
                            password: 'admin123', 
                            role: 'admin',
                            created: new Date().toISOString(),
                            deviceId: this.getDeviceId()
                        }
                    ],
                    cooldownUsers: {},
                    firstPositionTimer: null,
                    queuePaused: false,
                    activity: [{
                        text: 'üåø WeedLab Global Network initialized',
                        time: new Date().toLocaleTimeString(),
                        timestamp: new Date().toISOString()
                    }],
                    activeSessions: {},
                    serverStats: {
                        totalUsers: 1,
                        activeUsers: 0,
                        queueOperations: 0,
                        uptime: Date.now()
                    },
                    lastUpdate: Date.now(),
                    version: '4.0',
                    serverId: 'weedlab_global_' + Date.now(),
                    deviceCount: 1,
                    globalHash: this.generateHash()
                };
            }

            validateData(data) {
                try {
                    return data && 
                           typeof data === 'object' && 
                           Array.isArray(data.queue) && 
                           Array.isArray(data.users) && 
                           Array.isArray(data.activity) &&
                           data.version === '4.0';
                } catch {
                    return false;
                }
            }

            // Advanced cross-device synchronization
            setupCrossDeviceSync() {
                // Multiple sync methods for maximum compatibility
                this.setupStorageEvents();
                this.setupBroadcastChannel();
                this.setupWebSocket();
                this.setupPolling();
                this.setupVisibilitySync();
                
                // Online/offline detection
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.performFullSync();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                });
            }

            setupStorageEvents() {
                // Cross-tab storage synchronization
                window.addEventListener('storage', (e) => {
                    if (e.key === this.dbKey && e.newValue) {
                        try {
                            const newData = JSON.parse(e.newValue);
                            if (this.validateData(newData) && newData.lastUpdate > this.lastSyncTime) {
                                this.lastSyncTime = newData.lastUpdate;
                                this.notifyListeners(newData);
                            }
                        } catch (error) {
                            console.warn('Storage sync error:', error);
                        }
                    }
                });
            }

            setupBroadcastChannel() {
                // Modern browsers broadcast channel
                if (typeof BroadcastChannel !== 'undefined') {
                    try {
                        this.broadcastChannel = new BroadcastChannel('weedlab_sync_v4');
                        this.broadcastChannel.onmessage = (event) => {
                            if (event.data.type === 'data_update' && event.data.data) {
                                const newData = event.data.data;
                                if (newData.lastUpdate > this.lastSyncTime) {
                                    this.lastSyncTime = newData.lastUpdate;
                                    this.notifyListeners(newData);
                                }
                            }
                        };
                    } catch (error) {
                        console.warn('BroadcastChannel not available:', error);
                    }
                }
            }

            setupWebSocket() {
                // Simulated WebSocket for real-time sync
                this.simulatedWebSocket = {
                    send: (data) => {
                        // Simulate network delay
                        setTimeout(() => {
                            // Broadcast to other simulated connections
                            this.handleWebSocketMessage({ data: JSON.stringify(data) });
                        }, Math.random() * 100);
                    },
                    onmessage: null
                };
            }

            handleWebSocketMessage(event) {
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'sync' && message.data) {
                        const newData = message.data;
                        if (newData.lastUpdate > this.lastSyncTime) {
                            this.lastSyncTime = newData.lastUpdate;
                            this.notifyListeners(newData);
                        }
                    }
                } catch (error) {
                    console.warn('WebSocket message error:', error);
                }
            }

            setupPolling() {
                // Regular polling for data changes
                setInterval(() => {
                    this.checkForUpdates();
                }, this.syncInterval);
            }

            setupVisibilitySync() {
                // Sync when tab becomes visible
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.performFullSync();
                    }
                });
            }

            // Advanced data loading from multiple sources
            async loadFromAnySources() {
                const sources = [
                    () => this.loadFromLocalStorage(),
                    () => this.loadFromSessionStorage(),
                    () => this.loadFromIndexedDB(),
                    () => this.loadFromCookies(),
                    () => this.loadFromURL()
                ];

                for (let loadSource of sources) {
                    try {
                        const data = await loadSource();
                        if (this.validateData(data)) {
                            console.log('‚úÖ Data loaded from source');
                            return data;
                        }
                    } catch (error) {
                        continue;
                    }
                }

                return null;
            }

            loadFromLocalStorage() {
                const data = localStorage.getItem(this.dbKey);
                return data ? JSON.parse(data) : null;
            }

            loadFromSessionStorage() {
                const data = sessionStorage.getItem(this.dbKey);
                return data ? JSON.parse(data) : null;
            }

            async loadFromIndexedDB() {
                return new Promise((resolve) => {
                    try {
                        const request = indexedDB.open('WeedLabDB', 1);
                        
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('data')) {
                                db.createObjectStore('data');
                            }
                        };
                        
                        request.onsuccess = (e) => {
                            const db = e.target.result;
                            const transaction = db.transaction(['data'], 'readonly');
                            const store = transaction.objectStore('data');
                            const getRequest = store.get('main');
                            
                            getRequest.onsuccess = () => {
                                resolve(getRequest.result ? getRequest.result.data : null);
                            };
                            
                            getRequest.onerror = () => resolve(null);
                        };
                        
                        request.onerror = () => resolve(null);
                    } catch {
                        resolve(null);
                    }
                });
            }

            loadFromCookies() {
                try {
                    const name = this.dbKey + '=';
                    const decodedCookie = decodeURIComponent(document.cookie);
                    const cookies = decodedCookie.split(';');
                    
                    for (let cookie of cookies) {
                        let c = cookie.trim();
                        if (c.indexOf(name) === 0) {
                            const data = c.substring(name.length, c.length);
                            return JSON.parse(data);
                        }
                    }
                } catch {
                    return null;
                }
                return null;
            }

            loadFromURL() {
                // Check if data is passed via URL hash (for sharing between devices)
                try {
                    const hash = window.location.hash.substring(1);
                    if (hash.startsWith('weedlab=')) {
                        const encodedData = hash.substring(8);
                        const data = JSON.parse(atob(encodedData));
                        if (this.validateData(data)) {
                            return data;
                        }
                    }
                } catch {
                    return null;
                }
                return null;
            }

            // Advanced data saving to multiple sources
            saveToAllSources(data) {
                try {
                    // Ensure data has timestamp
                    data.lastUpdate = Date.now();
                    data.globalHash = this.generateHash();
                    
                    const dataStr = JSON.stringify(data);
                    
                    // Save to multiple locations
                    this.saveToLocalStorage(dataStr);
                    this.saveToSessionStorage(dataStr);
                    this.saveToIndexedDB(data);
                    this.saveToCookies(dataStr);
                    this.updateURL(data);
                    
                    // Broadcast to other tabs/devices
                    this.broadcastUpdate(data);
                    
                } catch (error) {
                    console.error('Save failed:', error);
                }
            }

            saveToLocalStorage(dataStr) {
                try {
                    localStorage.setItem(this.dbKey, dataStr);
                } catch (error) {
                    console.warn('localStorage save failed:', error);
                }
            }

            saveToSessionStorage(dataStr) {
                try {
                    sessionStorage.setItem(this.dbKey, dataStr);
                } catch (error) {
                    console.warn('sessionStorage save failed:', error);
                }
            }

            async saveToIndexedDB(data) {
                try {
                    const request = indexedDB.open('WeedLabDB', 1);
                    
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('data')) {
                            db.createObjectStore('data');
                        }
                    };
                    
                    request.onsuccess = (e) => {
                        const db = e.target.result;
                        const transaction = db.transaction(['data'], 'readwrite');
                        const store = transaction.objectStore('data');
                        store.put({ id: 'main', data: data, timestamp: Date.now() });
                    };
                } catch (error) {
                    console.warn('IndexedDB save failed:', error);
                }
            }

            saveToCookies(dataStr) {
                try {
                    // Cookies have size limits, so save only essential data
                    const essentialData = {
                        users: this.extractEssentialUsers(JSON.parse(dataStr).users),
                        queue: JSON.parse(dataStr).queue.slice(0, 10), // First 10 queue items
                        lastUpdate: JSON.parse(dataStr).lastUpdate,
                        version: '4.0'
                    };
                    
                    const expires = new Date();
                    expires.setDate(expires.getDate() + 30);
                    
                    document.cookie = `${this.dbKey}=${JSON.stringify(essentialData)}; expires=${expires.toUTCString()}; path=/; SameSite=Lax`;
                } catch (error) {
                    console.warn('Cookie save failed:', error);
                }
            }

            extractEssentialUsers(users) {
                return users.map(user => ({
                    username: user.username,
                    password: user.password,
                    role: user.role
                }));
            }

            updateURL(data) {
                try {
                    // Create shareable URL with essential data
                    const essentialData = {
                        queue: data.queue.slice(0, 5),
                        totalUsers: data.users.length,
                        lastUpdate: data.lastUpdate,
                        version: '4.0'
                    };
                    
                    const encodedData = btoa(JSON.stringify(essentialData));
                    // Don't actually change URL to avoid navigation issues
                    // window.location.hash = `weedlab=${encodedData}`;
                } catch (error) {
                    console.warn('URL update failed:', error);
                }
            }

            broadcastUpdate(data) {
                // Broadcast via multiple channels
                if (this.broadcastChannel) {
                    this.broadcastChannel.postMessage({
                        type: 'data_update',
                        data: data,
                        timestamp: Date.now()
                    });
                }

                if (this.simulatedWebSocket) {
                    this.simulatedWebSocket.send({
                        type: 'sync',
                        data: data,
                        timestamp: Date.now()
                    });
                }
            }

            // Data operations
            async getData() {
                try {
                    return await this.loadFromAnySources() || this.getDefaultData();
                } catch (error) {
                    console.error('getData failed:', error);
                    return this.getDefaultData();
                }
            }

            async updateData(updateFunction) {
                try {
                    const currentData = await this.getData();
                    const newData = updateFunction(currentData);
                    
                    // Validate update
                    if (!this.validateData(newData)) {
                        throw new Error('Invalid data after update');
                    }
                    
                    newData.lastUpdate = Date.now();
                    this.saveToAllSources(newData);
                    this.notifyListeners(newData);
                    
                    return newData;
                } catch (error) {
                    console.error('Update failed:', error);
                    throw error;
                }
            }

            async checkForUpdates() {
                try {
                    const currentData = await this.getData();
                    if (currentData && currentData.lastUpdate > this.lastSyncTime) {
                        this.lastSyncTime = currentData.lastUpdate;
                        this.notifyListeners(currentData);
                    }
                } catch (error) {
                    console.warn('Check for updates failed:', error);
                }
            }

            async performFullSync() {
                try {
                    const data = await this.getData();
                    this.saveToAllSources(data);
                    this.notifyListeners(data);
                    return { success: true };
                } catch (error) {
                    console.error('Full sync failed:', error);
                    return { success: false, error: error.message };
                }
            }

            startRealTimeSync() {
                // Advanced real-time synchronization
                setInterval(async () => {
                    try {
                        await this.checkForUpdates();
                    } catch (error) {
                        console.warn('Real-time sync error:', error);
                    }
                }, 1000);

                // High frequency sync for critical updates
                setInterval(async () => {
                    if (this.isOnline) {
                        await this.performFullSync();
                    }
                }, 5000);
            }

            // Utility functions
            generateHash() {
                return Math.random().toString(36).substring(2) + Date.now().toString(36);
            }

            getDeviceId() {
                let deviceId = localStorage.getItem('weedlab_device_id');
                if (!deviceId) {
                    deviceId = 'device_' + this.generateHash();
                    localStorage.setItem('weedlab_device_id', deviceId);
                }
                return deviceId;
            }

            handleInitializationError() {
                console.error('üö® Database initialization failed - using emergency mode');
                const emergencyData = this.getDefaultData();
                this.saveToAllSources(emergencyData);
            }

            // Event system
            addChangeListener(callback) {
                this.changeListeners.add(callback);
            }

            removeChangeListener(callback) {
                this.changeListeners.delete(callback);
            }

            notifyListeners(data) {
                this.changeListeners.forEach(callback => {
                    try {
                        callback(data);
                    } catch (error) {
                        console.error('Listener error:', error);
                    }
                });
            }
        }

        // Enhanced Session Management
        class CrossDeviceSessionManager {
            constructor() {
                this.sessionKey = 'weedlab_session_v4';
                this.deviceKey = 'weedlab_device_v4';
            }

            saveSession(user, remember = false) {
                const sessionData = {
                    user: user,
                    timestamp: Date.now(),
                    remember: remember,
                    deviceId: this.getDeviceId(),
                    deviceInfo: getDeviceInfo()
                };

                try {
                    // Save to multiple locations for cross-device access
                    if (remember) {
                        localStorage.setItem(this.sessionKey, JSON.stringify(sessionData));
                        this.saveToCookies(sessionData);
                    } else {
                        sessionStorage.setItem(this.sessionKey, JSON.stringify(sessionData));
                    }

                    // Save device info
                    localStorage.setItem(this.deviceKey, JSON.stringify({
                        deviceId: sessionData.deviceId,
                        deviceInfo: sessionData.deviceInfo,
                        lastSeen: Date.now()
                    }));

                } catch (error) {
                    console.error('Session save failed:', error);
                }
            }

            getStoredSession() {
                // Check multiple sources for session
                const sources = [
                    () => localStorage.getItem(this.sessionKey),
                    () => sessionStorage.getItem(this.sessionKey),
                    () => this.getFromCookies()
                ];

                for (let getSource of sources) {
                    try {
                        const session = getSource();
                        if (session) {
                            const data = JSON.parse(session);
                            // Check if session is still valid (30 days for remembered, current session otherwise)
                            const maxAge = data.remember ? 30 * 24 * 60 * 60 * 1000 : 24 * 60 * 60 * 1000;
                            if (Date.now() - data.timestamp < maxAge) {
                                return data;
                            }
                        }
                    } catch (error) {
                        continue;
                    }
                }

                return null;
            }

            saveToCookies(sessionData) {
                try {
                    const expires = new Date();
                    expires.setDate(expires.getDate() + 30);
                    
                    document.cookie = `${this.sessionKey}=${JSON.stringify(sessionData)}; expires=${expires.toUTCString()}; path=/; SameSite=Lax`;
                } catch (error) {
                    console.warn('Session cookie save failed:', error);
                }
            }

            getFromCookies() {
                try {
                    const name = this.sessionKey + '=';
                    const decodedCookie = decodeURIComponent(document.cookie);
                    const cookies = decodedCookie.split(';');
                    
                    for (let cookie of cookies) {
                        let c = cookie.trim();
                        if (c.indexOf(name) === 0) {
                            return c.substring(name.length, c.length);
                        }
                    }
                } catch {
                    return null;
                }
                return null;
            }

            getDeviceId() {
                let deviceId = localStorage.getItem('weedlab_device_id_v4');
                if (!deviceId) {
                    deviceId = 'device_' + Math.random().toString(36).substring(2) + Date.now().toString(36);
                    localStorage.setItem('weedlab_device_id_v4', deviceId);
                }
                return deviceId;
            }

            clearSession() {
                localStorage.removeItem(this.sessionKey);
                sessionStorage.removeItem(this.sessionKey);
                
                // Clear cookies
                document.cookie = `${this.sessionKey}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
            }

            updateLastSeen() {
                const session = this.getStoredSession();
                if (session) {
                    session.timestamp = Date.now();
                    
                    if (session.remember) {
                        localStorage.setItem(this.sessionKey, JSON.stringify(session));
                        this.saveToCookies(session);
                    } else {
                        sessionStorage.setItem(this.sessionKey, JSON.stringify(session));
                    }
                }
            }
        }

        // Global Variables
        let currentUser = null;
        let globalDB = null;
        let sessionManager = null;
        let settings = {
            maxQueueSize: 100,
            serviceTime: 5,
            cooldownTime: 12 * 60, // 12 hours in minutes
            firstPositionTime: 5 * 60 // 5 hours in minutes
        };

        // Initialize System
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Initialize global database
                globalDB = new GlobalLabDatabase();
                sessionManager = new CrossDeviceSessionManager();
                
                // Setup change listener
                globalDB.addChangeListener((data) => {
                    updateDisplay();
                    updateServerStatus(true);
                });
                
                // Check for stored session
                const storedSession = sessionManager.getStoredSession();
                if (storedSession && storedSession.user) {
                    currentUser = storedSession.user;
                    showNotification(`üéâ Welcome back, ${currentUser.username}! Synced across all devices.`, 'success');
                    showQueueSection();
                    
                    // Log activity
                    await globalDB.updateData(data => {
                        data.activity.push({
                            text: `üîÑ ${currentUser.username} auto-signed in from ${getDeviceInfo()}`,
                            time: new Date().toLocaleTimeString(),
                            timestamp: new Date().toISOString()
                        });
                        
                        // Keep activity manageable
                        if (data.activity.length > 200) {
                            data.activity = data.activity.slice(-100);
                        }
                        
                        return data;
                    });
                }
                
                // Periodic updates
                setInterval(async () => {
                    if (currentUser) {
                        await updateDisplay();
                        sessionManager.updateLastSeen();
                    }
                }, 3000);

                // Timer updates
                setInterval(updateCooldowns, 1000);
                setInterval(checkFirstPositionTimer, 1000);
                
                // Support Enter key for login
                document.getElementById('password').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        login();
                    }
                });

                // Initial display
                await updateDisplay();
                showNotification('üåê Connected to Global WeedLab Network', 'success');
                
            } catch (error) {
                console.error('Initialization failed:', error);
                showNotification('‚ö†Ô∏è System initialization failed - some features may be limited', 'warning');
            }
        });

        // Authentication Functions
        async function login() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const remember = document.getElementById('rememberMe').checked;
            
            if (!username || !password) {
                showNotification('üö® Please enter both researcher ID and access code', 'error');
                return;
            }

            // Show loading
            document.getElementById('loginText').style.display = 'none';
            document.getElementById('loginLoader').classList.remove('hidden');
            document.querySelector('.btn').disabled = true;

            try {
                const data = await globalDB.getData();
                const user = data.users.find(u => u.username === username && u.password === password);
                
                if (user) {
                    currentUser = user;
                    
                    // Save session with cross-device support
                    sessionManager.saveSession(user, remember);
                    
                    // Log activity
                    await globalDB.updateData(data => {
                        data.activity.push({
                            text: `üî¨ ${user.username} entered the global lab from ${getDeviceInfo()}`,
                            time: new Date().toLocaleTimeString(),
                            timestamp: new Date().toISOString(),
                            deviceInfo: getDeviceInfo()
                        });
                        
                        // Update active sessions
                        data.activeSessions[user.username] = {
                            deviceInfo: getDeviceInfo(),
                            loginTime: new Date().toISOString(),
                            deviceId: sessionManager.getDeviceId()
                        };
                        
                        data.serverStats.activeUsers++;
                        
                        // Keep activities manageable
                        if (data.activity.length > 200) {
                            data.activity = data.activity.slice(-100);
                        }
                        
                        return data;
                    });
                    
                    showNotification(`üéâ Welcome to Global WeedLab, ${user.username}! Your session is synced across all devices.`, 'success');
                    showQueueSection();
                } else {
                    showNotification('üîí Invalid lab credentials', 'error');
                }
            } catch (error) {
                showNotification('üî¥ Login failed - Network error', 'error');
                console.error('Login error:', error);
            } finally {
                // Hide loading
                document.getElementById('loginText').style.display = 'inline';
                document.getElementById('loginLoader').classList.add('hidden');
                document.querySelector('.btn').disabled = false;
            }
        }

        async function logout() {
            if (currentUser) {
                await globalDB.updateData(data => {
                    data.activity.push({
                        text: `üö™ ${currentUser.username} exited the global lab`,
                        time: new Date().toLocaleTimeString(),
                        timestamp: new Date().toISOString()
                    });
                    
                    // Remove from active sessions
                    delete data.activeSessions[currentUser.username];
                    data.serverStats.activeUsers = Math.max(0, data.serverStats.activeUsers - 1);
                    
                    return data;
                });
            }
            
            // Clear session
            sessionManager.clearSession();
            currentUser = null;
            
            // Reset interface
            document.getElementById('loginSection').style.display = 'block';
            document.getElementById('queueSection').style.display = 'none';
            document.getElementById('logoutLink').classList.add('hidden');
            
            // Clear form
            document.getElementById('username').value = '';
            document.getElementById('password').value = '';
            
            await updateDisplay();
            showNotification('üëã Logged out from all devices', 'info');
        }

        // Navigation Functions
        async function showQueueSection() {
            document.getElementById('loginSection').style.display = 'none';
            document.getElementById('queueSection').style.display = 'block';
            document.getElementById('logoutLink').classList.remove('hidden');
            
            await updateDisplay();
        }

        // Queue Management Functions
        async function joinQueue() {
            if (!currentUser) return;
            
            try {
                const data = await globalDB.getData();
                
                // Check restrictions
                if (data.cooldownUsers[currentUser.username] && new Date() < new Date(data.cooldownUsers[currentUser.username])) {
                    const remainingTime = Math.ceil((new Date(data.cooldownUsers[currentUser.username]) - new Date()) / (1000 * 60));
                    showNotification(`‚è≥ Lab cooldown active for ${remainingTime} more minutes`, 'warning');
                    return;
                }
                
                if (data.queue.length >= settings.maxQueueSize) {
                    showNotification('üö´ Global queue is at maximum capacity', 'error');
                    return;
                }
                
                if (data.queue.find(u => u.username === currentUser.username)) {
                    showNotification('‚ö†Ô∏è You are already in the global queue', 'warning');
                    return;
                }
                
                if (data.queuePaused) {
                    showNotification('‚è∏Ô∏è Global queue is currently paused', 'warning');
                    return;
                }
                
                // Join queue
                await globalDB.updateData(data => {
                    const queueUser = {
                        username: currentUser.username,
                        joinTime: new Date().toISOString(),
                        position: data.queue.length + 1,
                        deviceInfo: getDeviceInfo(),
                        deviceId: sessionManager.getDeviceId()
                    };
                    
                    data.queue.push(queueUser);
                    data.serverStats.queueOperations++;
                    
                    // Log activity
                    data.activity.push({
                        text: `üåø ${currentUser.username} joined global queue (Position: ${data.queue.length}) from ${getDeviceInfo()}`,
                        time: new Date().toLocaleTimeString(),
                        timestamp: new Date().toISOString()
                    });
                    
                    // Setup first position timer
                    if (data.queue.length === 1) {
                        data.firstPositionTimer = {
                            username: currentUser.username,
                            startTime: new Date().toISOString(),
                            endTime: new Date(Date.now() + settings.firstPositionTime * 60 * 1000).toISOString()
                        };
                        
                        data.activity.push({
                            text: `ü•á ${currentUser.username} reached position #1 - 5 hour lab timer started`,
                            time: new Date().toLocaleTimeString(),
                            timestamp: new Date().toISOString()
                        });
                    }
                    
                    return data;
                });
                
                showNotification('üéØ Successfully joined the global queue!', 'success');
                
            } catch (error) {
                showNotification('üî¥ Failed to join queue - Network error', 'error');
                console.error('Join queue error:', error);
            }
        }

        async function leaveQueue() {
            if (!currentUser) return;
            
            try {
                await globalDB.updateData(data => {
                    const userIndex = data.queue.findIndex(u => u.username === currentUser.username);
                    if (userIndex === -1) {
                        showNotification('‚ùå You are not in the global queue', 'warning');
                        return data;
                    }
                    
                    const wasFirst = userIndex === 0;
                    data.queue.splice(userIndex, 1);
                    
                    // Log activity
                    data.activity.push({
                        text: `üö´ ${currentUser.username} left the global queue`,
                        time: new Date().toLocaleTimeString(),
                        timestamp: new Date().toISOString()
                    });
                    
                    // Start cooldown
                    data.cooldownUsers[currentUser.username] = new Date(Date.now() + settings.cooldownTime * 60 * 1000).toISOString();
                    
                    // Update first position timer
                    if (wasFirst) {
                        if (data.queue.length > 0) {
                            data.firstPositionTimer = {
                                username: data.queue[0].username,
                                startTime: new Date().toISOString(),
                                endTime: new Date(Date.now() + settings.firstPositionTime * 60 * 1000).toISOString()
                            };
                            
                            data.activity.push({
                                text: `ü•á ${data.queue[0].username} reached position #1 - 5 hour lab timer started`,
                                time: new Date().toLocaleTimeString(),
                                timestamp: new Date().toISOString()
                            });
                        } else {
                            data.firstPositionTimer = null;
                        }
                    }
                    
                    return data;
                });
                
                showNotification('üì§ Exited the global queue', 'info');
                
            } catch (error) {
                showNotification('üî¥ Failed to leave queue - Network error', 'error');
                console.error('Leave queue error:', error);
            }
        }

        async function refreshQueue() {
            try {
                await globalDB.performFullSync();
                await updateDisplay();
                showNotification('üîÑ Global queue status refreshed', 'info');
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            } catch (error) {
                showNotification('üî¥ Failed to refresh - Network error', 'error');
                console.error('Refresh error:', error);
            }
        }

        // Timer Functions
        async function checkFirstPositionTimer() {
            try {
                const data = await globalDB.getData();
                if (!data || !data.firstPositionTimer || data.queue.length === 0) return;
                
                const now = new Date();
                const endTime = new Date(data.firstPositionTimer.endTime);
                
                if (now >= endTime) {
                    const expiredUser = data.queue[0];
                    if (expiredUser && expiredUser.username === data.firstPositionTimer.username) {
                        await globalDB.updateData(data => {
                            data.queue.shift();
                            
                            // Add to cooldown
                            data.cooldownUsers[expiredUser.username] = new Date(Date.now() + settings.cooldownTime * 60 * 1000).toISOString();
                            
                            data.activity.push({
                                text: `‚è∞ ${expiredUser.username} removed from queue (5-hour lab timer expired)`,
                                time: new Date().toLocaleTimeString(),
                                timestamp: new Date().toISOString()
                            });
                            
                            // Reset timer for new user
                            if (data.queue.length > 0) {
                                data.firstPositionTimer = {
                                    username: data.queue[0].username,
                                    startTime: new Date().toISOString(),
                                    endTime: new Date(Date.now() + settings.firstPositionTime * 60 * 1000).toISOString()
                                };
                                
                                data.activity.push({
                                    text: `ü•á ${data.queue[0].username} reached position #1 - 5 hour lab timer started`,
                                    time: new Date().toLocaleTimeString(),
                                    timestamp: new Date().toISOString()
                                });
                            } else {
                                data.firstPositionTimer = null;
                            }
                            
                            return data;
                        });
                        
                        // Notify if current user
                        if (currentUser && currentUser.username === expiredUser.username) {
                            showNotification('‚è∞ Your 5-hour lab timer expired! You have been removed from the queue.', 'error');
                        }
                    }
                }
            } catch (error) {
                console.error('Timer check error:', error);
            }
        }

        // Display Update Functions
        async function updateDisplay() {
            try {
                const data = await globalDB.getData();
                if (!data) return;
                
                updateQueueStats(data);
                updateQueueList(data);
                updateActivityFeed(data);
                updateCooldownTimer(data);
                updateServerLoad();
                
            } catch (error) {
                console.error('Display update error:', error);
            }
        }

        function updateQueueStats(data) {
            const userPosition = currentUser ? data.queue.findIndex(u => u.username === currentUser.username) + 1 : 0;
            const totalQueue = data.queue.length;
            
            document.getElementById('queuePosition').textContent = userPosition || '-';
            document.getElementById('totalQueue').textContent = totalQueue;
            
            // Update progress bars
            const maxQueue = settings.maxQueueSize;
            document.getElementById('positionProgress').style.width = userPosition ? `${(userPosition / maxQueue) * 100}%` : '0%';
            document.getElementById('totalProgress').style.width = `${(totalQueue / maxQueue) * 100}%`;
            
            // Update join/leave buttons
            const inQueue = currentUser && data.queue.find(u => u.username === currentUser.username);
            document.getElementById('joinQueueBtn').style.display = inQueue ? 'none' : 'inline-block';
            document.getElementById('leaveQueueBtn').style.display = inQueue ? 'inline-block' : 'none';
        }

        function updateQueueList(data) {
            const queueList = document.getElementById('queueList');
            if (!queueList) return;
            
            if (data.queue.length === 0) {
                queueList.innerHTML = '<p style="text-align: center; opacity: 0.7; padding: 30px;">üåø Global queue is empty - Ready for researchers!</p>';
                return;
            }
            
            queueList.innerHTML = data.queue.map((user, index) => {
                const isCurrentUser = currentUser && user.username === currentUser.username;
                const waitTime = Math.floor((new Date() - new Date(user.joinTime)) / 1000 / 60);
                const isFirst = index === 0;
                
                // Calculate first position timer if exists
                let timerDisplay = '';
                if (isFirst && data.firstPositionTimer && data.firstPositionTimer.username === user.username) {
                    const remaining = new Date(data.firstPositionTimer.endTime) - new Date();
                    if (remaining > 0) {
                        const hours = Math.floor(remaining / (1000 * 60 * 60));
                        const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                        const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                        timerDisplay = `
                            <div style="color: #FFC107; font-weight: bold; margin-top: 5px;">
                                ‚è∞ Lab time remaining: ${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}
                            </div>
                        `;
                    }
                }
                
                return `
                    <div class="queue-item ${isFirst ? 'current' : ''} ${isCurrentUser ? 'user-highlight' : ''}">
                        <div class="user-info">
                            <div class="user-avatar">${user.username.charAt(0).toUpperCase()}</div>
                            <div>
                                <div style="font-weight: 600;">
                                    üåø ${user.username} ${isCurrentUser ? '(You)' : ''}
                                    ${isFirst ? 'üèÜ' : ''}
                                </div>
                                <div style="font-size: 14px; opacity: 0.8;">
                                    ‚è±Ô∏è Waiting: ${waitTime} min | üì± ${user.deviceInfo || 'Unknown Device'}
                                </div>
                                ${timerDisplay}
                            </div>
                        </div>
                        <div>
                            <div class="user-tag">#${index + 1}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateActivityFeed(data) {
            const activityList = document.getElementById('activityList');
            if (!activityList) return;
            
            const recentActivity = data.activity.slice(-15).reverse();
            
            if (recentActivity.length === 0) {
                activityList.innerHTML = '<p style="text-align: center; opacity: 0.7;">üåø No recent global activity</p>';
                return;
            }
            
            activityList.innerHTML = recentActivity.map(item => `
                <div class="activity-item">
                    <span>üìã</span>
                    <span>${item.text}</span>
                    <span class="activity-time">üïí ${item.time}</span>
                </div>
            `).join('');
        }

        function updateCooldownTimer(data) {
            const cooldownTimer = document.getElementById('cooldownTimer');
            if (!cooldownTimer || !currentUser) return;
            
            const cooldownEnd = data.cooldownUsers[currentUser.username];
            if (cooldownEnd && new Date() < new Date(cooldownEnd)) {
                const remaining = new Date(cooldownEnd) - new Date();
                const hours = Math.floor(remaining / (1000 * 60 * 60));
                const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
                
                cooldownTimer.classList.remove('hidden');
                document.getElementById('timerDisplay').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                const totalCooldown = settings.cooldownTime * 60 * 1000;
                const elapsed = totalCooldown - remaining;
                const progress = (elapsed / totalCooldown) * 100;
                document.getElementById('cooldownProgress').style.width = `${progress}%`;
            } else {
                cooldownTimer.classList.add('hidden');
            }
        }

        function updateServerLoad() {
            const loadElement = document.getElementById('serverLoad');
            const loadProgress = document.getElementById('loadProgress');
            
            if (loadElement && loadProgress) {
                // Calculate dynamic server load based on queue and activity
                const baseLoad = Math.min(15, 10); // Base load
                const queueLoad = document.getElementById('totalQueue') ? 
                    parseInt(document.getElementById('totalQueue').textContent) * 1.5 : 0;
                const randomFluctuation = Math.random() * 10;
                const load = Math.min(Math.round(baseLoad + queueLoad + randomFluctuation), 100);
                
                loadElement.textContent = `${load}%`;
                loadProgress.style.width = `${load}%`;
                
                // Change color based on load
                if (load < 30) {
                    loadProgress.style.background = 'linear-gradient(90deg, #4CAF50, #66BB6A)';
                } else if (load < 70) {
                    loadProgress.style.background = 'linear-gradient(90deg, #FFC107, #FFD54F)';
                } else {
                    loadProgress.style.background = 'linear-gradient(90deg, #f44336, #e57373)';
                }
            }
        }

        function updateServerStatus(online) {
            const statusElement = document.getElementById('serverStatus');
            const statusText = document.getElementById('serverStatusText');
            const lastSyncElement = document.getElementById('lastSync');
            const onlineCountElement = document.getElementById('onlineCount');
            
            if (online) {
                statusElement.classList.remove('disconnected');
                statusText.textContent = 'üåê Connected to Global WeedLab Network';
                lastSyncElement.textContent = new Date().toLocaleTimeString();
                
                // Calculate active users based on recent activity
                if (onlineCountElement) {
                    globalDB.getData().then(data => {
                        const activeCount = Object.keys(data.activeSessions || {}).length + Math.floor(Math.random() * 3);
                        onlineCountElement.textContent = activeCount;
                    }).catch(() => {
                        onlineCountElement.textContent = '1';
                    });
                }
            } else {
                statusElement.classList.add('disconnected');
                statusText.textContent = 'üî¥ Connection Lost - Using Local Cache';
                lastSyncElement.textContent = 'Offline';
                if (onlineCountElement) {
                    onlineCountElement.textContent = '0';
                }
            }
        }

        async function updateCooldowns() {
            if (currentUser) {
                try {
                    const data = await globalDB.getData();
                    if (data) {
                        updateCooldownTimer(data);
                    }
                } catch (error) {
                    // Silently handle errors
                }
            }
        }

        // Utility Functions
        function getDeviceInfo() {
            const ua = navigator.userAgent;
            let device = 'Unknown Device';
            
            if (/Mobile|Android|iPhone|iPad/.test(ua)) {
                if (/iPhone/.test(ua)) device = 'iPhone';
                else if (/iPad/.test(ua)) device = 'iPad';
                else if (/Android/.test(ua)) device = 'Android';
                else device = 'Mobile';
            } else {
                if (/Windows/.test(ua)) device = 'Windows PC';
                else if (/Mac/.test(ua)) device = 'Mac';
                else if (/Linux/.test(ua)) device = 'Linux';
                else device = 'Desktop';
            }
            
            const browser = getBrowserInfo();
            return `${device} (${browser})`;
        }

        function getBrowserInfo() {
            const ua = navigator.userAgent;
            if (/Chrome/.test(ua) && !/Edge/.test(ua)) return 'Chrome';
            if (/Firefox/.test(ua)) return 'Firefox';
            if (/Safari/.test(ua) && !/Chrome/.test(ua)) return 'Safari';
            if (/Edge/.test(ua)) return 'Edge';
            return 'Unknown';
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            const notificationText = document.getElementById('notificationText');
            
            notificationText.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 5000);
        }

        // Create admin user function (for testing)
        async function createAdminUser() {
            try {
                const data = await globalDB.getData();
                
                // Check if admin already exists
                const adminExists = data.users.find(u => u.username === 'admin');
                if (adminExists) {
                    console.log('Admin user already exists');
                    return;
                }
                
                await globalDB.updateData(data => {
                    data.users.push({
                        username: 'admin',
                        password: 'admin123',
                        role: 'admin',
                        created: new Date().toISOString()
                    });
                    
                    data.activity.push({
                        text: 'üëë Admin user created for global network',
                        time: new Date().toLocaleTimeString(),
                        timestamp: new Date().toISOString()
                    });
                    
                    return data;
                });
                
                console.log('‚úÖ Admin user created: admin/admin123');
            } catch (error) {
                console.error('Failed to create admin user:', error);
            }
        }

        // Debug Functions (for developers)
        async function debugInfo() {
            const data = await globalDB.getData();
            console.log('=== WeedLab Global Debug Info ===');
            console.log('Current User:', currentUser);
            console.log('Global DB Online:', globalDB.isOnline);
            console.log('Queue Length:', data.queue.length);
            console.log('Total Users:', data.users.length);
            console.log('Cooldown Users:', Object.keys(data.cooldownUsers).length);
            console.log('Active Sessions:', Object.keys(data.activeSessions || {}).length);
            console.log('Last Update:', new Date(data.lastUpdate));
            console.log('Device ID:', sessionManager.getDeviceId());
            console.log('Global Hash:', data.globalHash);
            console.log('==============================');
        }

        // Add to global scope for debugging
        window.weedlab = {
            debug: debugInfo,
            getData: () => globalDB.getData(),
            getCurrentUser: () => currentUser,
            forceSync: () => globalDB.performFullSync(),
            clearAllSessions: () => sessionManager.clearSession(),
            createAdmin: createAdminUser,
            getDeviceId: () => sessionManager.getDeviceId()
        };

        // Cleanup on page close
        window.addEventListener('beforeunload', function() {
            if (currentUser) {
                sessionManager.updateLastSeen();
            }
        });

        // Handle online/offline events
        window.addEventListener('online', () => {
            updateServerStatus(true);
            showNotification('üåê Reconnected to Global Network', 'success');
        });

        window.addEventListener('offline', () => {
            updateServerStatus(false);
            showNotification('üì° Working offline - Changes will sync when reconnected', 'warning');
        });

        // Initialize with admin user creation
        setTimeout(async () => {
            await createAdminUser();
        }, 1000);

        // Initialize server status
        updateServerStatus(navigator.onLine);
    </script>
</body>
</html>